---
path: '/sdk/client-side/android'
title: 'Android SDK reference'
description: 'This topic explains all the methods available in the Android SDK.'
published: true
---

<Callout intent="info">
<CalloutTitle>Supported Android SDK Versions</CalloutTitle>
<CalloutDescription>

This library is compatible with Android SDK versions 16 and up (4.1 Jelly Bean)

</CalloutDescription>
</Callout>

This reference guide documents all of the methods available in our Android SDK, and explains in detail how these methods work. If you want to dig even deeper, our SDKs are open source. To learn more, view the source on [GitHub](https://github.com/launchdarkly/android-client-sdk) or the generated [Javadocs](https://launchdarkly.github.io/android-client-sdk/). Additionally you can clone and run a [sample application](https://github.com/launchdarkly/hello-android) that uses this SDK.

## Getting started

Building on top of our [Getting Started guide](/home/getting-started) guide, the following steps will get you started with using the LaunchDarkly SDK in your Android application.

To get started, declare a dependency on the LaunchDarkly Android SDK.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Gradle', value: 'java', },
  ]
}>
<CodeTabItem value="java">

```java
implementation 'com.launchdarkly:launchdarkly-android-client-sdk:2.11.0'
```

</CodeTabItem>
</CodeTabs>

<Callout intent="info">
  <CalloutTitle>ProGuard / R8</CalloutTitle>
<CalloutDescription>


If you're using ProGuard or R8, the configuration for the Android SDK should be automatically included from the `aar` artifact. If this is not the case for your build, include the Proguard configuration lines from [consumer-proguard-rules.pro](https://github.com/launchdarkly/android-client-sdk/blob/master/launchdarkly-android-client-sdk/consumer-proguard-rules.pro)
into your proguard file.

</CalloutDescription>
</Callout>

Once the SDK is installed, you'll want to create a single, shared instance of `LDClient`. You should specify your _mobile key_ here so that your application will be authorized to connect to LaunchDarkly and retrieve flag values for your application and environment.

The following example shows the simplest way to create the client. It will block for up to 5 seconds until the latest feature flags have been retrieved from LaunchDarkly.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java' },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDConfig ldConfig = new LDConfig.Builder() 
    .setMobileKey("YOUR_MOBILE_KEY") 
    .build();

LDUser user = new LDUser.Builder("user key")
    .email("fake@example.com")
    .build();

LDClient ldClient = LDClient.init(this.getApplication(), ldConfig, user, 5);
```

</CodeTabItem>

<CodeTabItem value="kotlin">

```kotlin
val ldConfig: LDConfig = LDConfig.Builder()
    .setMobileKey("YOUR_MOBILE_KEY")
    .build()

val user: LDUser = LDUser.Builder("user key")
    .email("fake@example.com")
    .build()

val ldClient: LDClient = LDClient.init(application, ldConfig, user, 5)
```

</CodeTabItem>
</CodeTabs>

<Callout intent="info">
  <CalloutTitle>Use a mobile key</CalloutTitle>
<CalloutDescription>


Be sure to use a mobile key from your [Environments](https://app.launchdarkly.com/settings#/environments) page. Never embed a server-side SDK key into an embedded or desktop application.

</CalloutDescription>
</Callout>

However, calling blocking code from the main thread in an Android app is not considered a best practice. The preferred method is shown below. It will allow you to use the client immediately. Flags from the previous launch of the app are stored on the device and retrieved for immediate use. The client will still connect in the background and continually update itself with the latest flags.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDClient ldClient = LDClient.init(this.getApplication(), ldConfig, user, 0);
```

</CodeTabItem>

<CodeTabItem value="kotlin">

```kotlin
val ldClient: LDClient = LDClient.init(application, ldConfig, user, 0)
```

</CodeTabItem>
</CodeTabs>

Using `ldClient`, you can check which variation a particular user should receive for a given feature flag.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
boolean showFeature = ldClient.boolVariation(flagKey, true);
if (showFeature) {
    // application code to show the feature
}
else {
    // the code to run if the feature is off
}
```

</CodeTabItem>

<CodeTabItem value="kotlin">

```kotlin
val showFeature: Boolean = ldClient.boolVariation(flagKey, true)
if (showFeature) {
    // application code to show the feature
}
else {
    // the code to run if the feature is off
}
```

</CodeTabItem>
</CodeTabs>

Lastly, when your application is about to terminate, shut down `ldClient`. This ensures that the client releases any resources it is using, and that any pending analytics events are delivered to LaunchDarkly. If your application quits without this shutdown step, you may not see your requests and users on the dashboard, because they are derived from analytics events. **This is something you only need to do once**.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
ldClient.close();
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
ldClient.close()
```

</CodeTabItem>
</CodeTabs>

## Customizing your client

You can also pass other custom parameters to the client with the configuration object:

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDConfig ldConfig = new LDConfig.Builder()
    .setMobileKey("YOUR_MOBILE_KEY")
    .setConnectionTimeoutMillis(5000)
    .setEventsFlushIntervalMillis(5000)
    .build();
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val ldConfig: LDConfig = LDConfig.Builder()
    .setMobileKey("YOUR_MOBILE_KEY")
    .setConnectionTimeoutMillis(5000)
    .setEventsFlushIntervalMillis(5000)
    .build()
```

</CodeTabItem>
</CodeTabs>

Here, we've customized the client connect and flush interval parameters. For the full set of config options check out the [Javadoc](https://launchdarkly.github.io/android-client-sdk/com/launchdarkly/android/LDConfig.Builder.html).

## Users
Feature flag targeting and rollouts are all determined by the *user* you pass to your client. In our Android SDK, we use a [builder pattern](https://en.wikipedia.org/wiki/Builder_pattern) to make it easy to construct users. Here's an example:

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDUser user = new LDUser.Builder("aa0ceb")
    .email("fake@example.com")
    .firstName("Jake")
    .lastName("Fake")
    .custom("group", "microsoft")
    .build();
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val user: LDUser = LDUser.Builder("aa0ceb")
    .email("fake@example.com")
    .firstName("Jake")
    .lastName("Fake")
    .custom("group", "microsoft")
    .build()
```

</CodeTabItem>
</CodeTabs>

Let's walk through this snippet. The first argument to the builder is the user's key. In this case we've used the hash `"aa0ceb"`. **The user key is the only mandatory user attribute**. The key should also uniquely identify each user. You can use a primary key, an e-mail address, or a hash, as long as the same user always has the same key. We recommend using a hash if possible.

All of the other attributes (like `firstName`, `email`, and the `custom` attributes) are optional. The attributes you specify will automatically appear on our dashboard, meaning that you can start segmenting and targeting users with these attributes.

In addition to built-in attributes like names and e-mail addresses, you can pass us any of your own user data by passing `custom` attributes, like the `groups` attribute in the example above.

<Callout intent="info">
<CalloutTitle>A note on types</CalloutTitle>
<CalloutDescription>

Most of our built-in attributes (like names and e-mail addresses) expect string values. Custom attributes values can be strings, booleans (like true or false), numbers, or lists of strings, booleans or numbers. If you enter a custom value on our dashboard that looks like a number or a boolean, it'll be interpreted that way. The Android SDK is strongly typed, so be aware of this distinction.

</CalloutDescription>
</Callout>

Custom attributes are one of the most powerful features of LaunchDarkly. They let you target users according to any data that you want to send to us, including organizations, groups, and account plans. Anything you pass to us becomes available instantly on our dashboard.

## Private user attributes

You can optionally configure the Android SDK to treat some or all user attributes as [private user attributes](/home/managing-users/user-attributes#creating-private-user-attributes). Private user attributes can be used for targeting purposes, but are removed from the user data sent back to LaunchDarkly.

In the Android SDK you can define private attributes for the **entire** LaunchDarkly client. When creating the `LDConfig` object, you can call the `setPrivateAttributeNames` method, which which takes in a set of custom or built-in attributes as a parameter. If any user has a custom or built-in attribute named in this set, it will be removed before the user is sent to LaunchDarkly.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
HashSet<String> privateAttributes = new HashSet<>();
privateAttributes.add("name");  // built-in attribute
privateAttributes.add("group"); // custom attribute

LDConfig ldConfig = new LDConfig.Builder()
    .setPrivateAttributeNames(privateAttributes)
    .build();
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val privateAttributes: HashSet<String> = HashSet()
privateAttributes.add("name")  // built-in attribute
privateAttributes.add("group") // custom attribute

val ldConfig: LDConfig = LDConfig.Builder()
    .setPrivateAttributeNames(privateAttributes)
    .build()
```

</CodeTabItem>
</CodeTabs>

You can also mark attributes as private when building the user object itself by using the private versions of the builder methods to set the attributes. For example:

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDUser user = new LDUser.Builder("aa0ceb")
    .email("fake@example.com")
    .privateName("Jane")
    .privateCustom("group", "microsoft")
    .build();
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val user: LDUser = LDUser.Builder("aa0ceb")
    .email("fake@example.com")
    .privateName("Jane")
    .privateCustom("group", "microsoft")
    .build()
```

</CodeTabItem>
</CodeTabs>

When this user is sent back to LaunchDarkly, the `name` and `group` attributes will be removed.

## Anonymous users

You can also distinguish logged-in users from anonymous users in the SDK, as follows:

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDUser user = new LDUser.Builder("user key")
    .anonymous(true)
    .build();
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val user: LDUser = LDUser.Builder("user key")
    .anonymous(true)
    .build()
```

</CodeTabItem>
</CodeTabs>

You can leave the key parameter in the Builder null or make it an empty string and the client will automatically set it to a LaunchDarkly-specific device-unique string that is consistent between app restarts and device reboots.

Anonymous users work just like regular users, except that they won't appear on your Users page in LaunchDarkly. You also can't search for anonymous users on your Features page, and you can't search or autocomplete by anonymous user keys. This is actually a good thing, because it keeps anonymous users from polluting your Users page!

## Variation
The `variation` method determines whether a flag is enabled or not for a specific user. In Android, there is  a `variation` method for each type (e.g. `boolVariation`, `stringVariation`):

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
boolean variationResult = ldClient.boolVariation(flagKey, false);
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val variationResult: Boolean = ldClient.boolVariation(flagKey, false)
```

</CodeTabItem>
</CodeTabs>

`variation` calls take the feature flag key and a fallback value.

The fallback value will only be returned if an error is encountered. For example, the fallback value is served if the feature flag key doesn't exist or the user doesn't have a key specified.

The `variation` call will automatically create a user in LaunchDarkly if a user with that user key doesn't exist already. There's no need to create users ahead of time (but if you do need to, take a look at `identify`).

<Callout intent="info">
<CalloutTitle>Handling flag values on initial application launch</CalloutTitle>
<CalloutDescription>

When `LDClient` is initialized for the first time at app launch, users will receive the feature flag fallback values until an initial connection to LaunchDarkly is completed for the first time. Take a look at the section above on various ways to initialize the client.

</CalloutDescription>
</Callout>

## VariationDetail

<Callout intent="info">
  <CalloutTitle>Availability</CalloutTitle>
<CalloutDescription>
Since V2.7.0</CalloutDescription>
</Callout>

The `variationDetail` methods (`boolVariationDetail`, etc.) work the same as `variation`, but also provide additional "reason" information about how a flag value was calculated (for instance, if the user matched a specific rule). You can examine the "reason" data programmatically; you can also view it with data export, if you are capturing detailed analytics events for this flag.

To learn more, read [Evaluation reasons](/sdk/concepts/evaluation-reasons).

## All flags

<Callout intent="alert">
<CalloutTitle>Creating users</CalloutTitle>
<CalloutDescription>

Note that unlike variation and identify calls, allFlags does not send events to LaunchDarkly. Thus, users are not created or updated in the LaunchDarkly dashboard.

</CalloutDescription>
</Callout>

The `allFlags` method produces a map of feature flag keys to their values for a specific user.


<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
ldClient.allFlags();
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
ldClient.allFlags()
```

</CodeTabItem>
</CodeTabs>

## Track

The `track` method allows you to record actions your users take in your application. In LaunchDarkly, you can tie these events to goals in A/B tests. You can also attach custom JSON data to your event by passing an extra `JsonElement` parameter to `track`. Here's a simple example:

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
ldClient.track("your-goal-key", data);
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
ldClient.track("your-goal-key", data)
```

</CodeTabItem>
</CodeTabs>

## Offline mode
In some situations, you might want to stop making remote calls to LaunchDarkly and switch to the last known values for your feature flags.  `offline` mode lets you do this easily.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDConfig ldConfig = new LDConfig.Builder() 
    .setMobileKey("YOUR_MOBILE_KEY") 
    .setOffline(true)
    .build();

LDClient ldClient = LDClient.init(this.getApplication(), ldConfig, user);

// Or to switch an already-instantiated client to offline mode:
ldClient.setOffline();
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val ldConfig: LDConfig = LDConfig.Builder() 
    .setMobileKey("YOUR_MOBILE_KEY") 
    .setOffline(true)
    .build()

val ldClient: LDClient = LDClient.init(application, ldConfig, user);

// Or to switch an already-instantiated client to offline mode:
ldClient.setOffline()
```

</CodeTabItem>
</CodeTabs>

<Callout intent="info">
<CalloutTitle>Airplane/Flight Mode</CalloutTitle>
<CalloutDescription>

If a user's device is in airplane/flight mode or if they are not connected to a network, LaunchDarkly will use the latest stored flag settings in memory. If there are no previously stored flag settings, then the fallback values will be used.

</CalloutDescription>
</Callout>

## Flush
Internally, the LaunchDarkly SDK keeps an event buffer for `track` calls. These are flushed periodically in a background thread. In some situations (for example, if you're testing out the SDK in a simulator), you may want to manually call `flush` to request any queued events to be sent immediately. Note that this call is still non-blocking, so it will return before the events are actually sent.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
ldClient.flush();
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
ldClient.flush()
```

</CodeTabItem>
</CodeTabs>

The flush interval is configurable. If you need to change the interval, you can do so via the configuration.

## Changing the User Context

If your app is used by multiple users on a single device, you may want to change users and have separate flag settings for each user. To achieve this, the SDK will store the last 5 user contexts on a single device, with support for switching between different user contexts.

You can use the `identify` method to switch user contexts:

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDUser updatedUser = new LDUser.Builder(user)
    .email("fake2@example.com")
    .build();

ldClient.identify(updatedUser);
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val updatedUser: LDUser = LDUser.Builder(user)
    .email("fake2@example.com")
    .build()

ldClient.identify(updatedUser)
```

</CodeTabItem>
</CodeTabs>

The `identify` call will load any saved flag values for the new user and immediately trigger an update of the latest flags from LaunchDarkly.

`identify` returns a [Future](https://developer.android.com/reference/java/util/concurrent/Future) to indicate completion. If you want to be sure subsequent code is using the latest values from the server, you can wait on the future using `get`.

## Real-Time Updates

The SDK maintains what variations a user should receive locally in cache. The SDK evaluates flags based on what it has cached locally. To keep the local cache in sync with your flag configurations in LaunchDarkly, the SDK uses both a streaming strategy and a polling strategy. The SDK is highly configurable, but the default SDK configuration has low latency updates, minimal data usage, and minimal battery drain. Here is the default behavior:

1. When the app is foregrounded a [Server-Sent Events](https://en.wikipedia.org/wiki/Server-sent_events) streaming connection is opened to LaunchDarkly. The initial payload from the streaming connection contains the variations your user receives. This streaming connection stays open and idles unless there are updates. This requires minimal data and battery to maintain. The streaming connection stays open as long as your app is in the foreground and is connected to the internet.
2. When the app is backgrounded, the stream connection terminates. The SDK polls for flag updates every hour (or another interval you configure) to stay in sync. This strategy has higher latency, but optimizes battery and data usage.
3. When the app is foregrounded, the SDK reconnects to the stream which sends the latest flag values.
4. When streaming, the SDK actively monitors the network availability. It avoids requests when the network is unavailable, and reconnects when the network becomes available again. When polling, the SDK checks for network connectivity at the current polling interval, only making the request if the check succeeds. When it reconnects, it automatically syncs its local cache with LaunchDarkly.

This configuration means that you will get near real-time updates for your feature flag values when the app is in the foreground, and maximum efficiency when backgrounded. See the "customizing your client" section above for information on how to change your configuration.

To perform real-time updates in your app, your app will need to register listeners to be notified of changes to a flag's value when it is updated:

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
String flagKey = "yourFlagKey";

FeatureFlagChangeListener listener = new FeatureFlagChangeListener() {
    @Override
    public void onFeatureFlagChange(String flagKey) {
        boolean newValue = LDClient.get().boolVariation(flagKey, false);
    }
};

LDClient.get().registerFeatureFlagListener(flagKey, listener);
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val flagKey = "yourFlagKey"

val listener = FeatureFlagChangeListener {
    val newValue = LDClient.get().boolVariation(flagKey, false)
}

LDClient.get().registerFeatureFlagListener(flagKey, listener)
```

</CodeTabItem>
</CodeTabs>

The flag key passed to `onFeatureFlagChange` is the key of the updated flag, allowing a single listener to be registered for multiple flags.

Similarly you can unregister listeners to disable them:

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDClient.get().unregisterFeatureFlagListener(flagKey, listener);
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
LDClient.get().unregisterFeatureFlagListener(flagKey, listener)
```

</CodeTabItem>
</CodeTabs>

---

<Callout intent="info">
<CalloutTitle>Availability</CalloutTitle>
<CalloutDescription>

These calls have been available since V2.8.0: 

* `LDAllFlagsListener`
* `LDClient.registerAllFlagsListener`
* `LDClient.unregisterAllFlagsListener`

</CalloutDescription>
</Callout>

Additionally an update listener interface is provided for cases where you would like to be notified any time the flag cache is updated. The application provides a class implementing `LDAllFlagsListener` which provides the SDK with the method `onChange`. Whenever the SDK's flag cache is updated it will call the `onChange` method with a list of flag keys for flags that were updated during the update to the flag cache. If no flag values changed, this list will be empty.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDAllFlagsListener listener = new LDAllFlagsListener() {
    @Override
    public void onChange(List<String> flagKeys) {
        // Get new values for flagKeys or other operations
    }
};

// register all flags listener
LDClient.get().registerAllFlagsListener(listener);
// when done with all flags listener it should be unregistered
LDClient.get().unregisterAllFlagsListener(listener);
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val listener = LDAllFlagsListener {
    // Get new values for flag keys (from implicit "it" list variable) or other operations
}

// register all flags listener
LDClient.get().registerAllFlagsListener(listener)
// when done with all flags listener it should be unregistered
LDClient.get().unregisterAllFlagsListener(listener)
```

</CodeTabItem>
</CodeTabs>

## Multiple Environments

<Callout intent="info">
  <CalloutTitle>Availablility</CalloutTitle>
<CalloutDescription>
This has been available since version 2.6.0</CalloutDescription>
</Callout>

LaunchDarkly's Android SDK supports having multiple LDClient instances tied to separate mobile keys. This allows evaluating flags from multiple environments.

All LDClient instances will evaluate against the same LDUser. The mobile keys for additional environments are specified, along with identifying names, in a map passed to your LDConfig object.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
Map<String, String> otherKeys = new HashMap<String, String>();
otherKeys.put("platform", "PLATFORM_MOBILE_KEY");
otherKeys.put("core", "CORE_MOBILE_KEY");

LDConfig ldConfig = new LDConfig.Builder()
    .setMobileKey("MOBILE_KEY")
    .setSecondaryMobileKeys(otherKeys)
    .build();

LDUser user = new LDUser.Builder("user key")
    .email("fake@example.com")
    .build();

LDClient.init(this.getApplication(), ldConfig, user);
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val otherKeys: Map<String, String> = HashMap()
otherKeys.put("platform", "PLATFORM_MOBILE_KEY")
otherKeys.put("core", "CORE_MOBILE_KEY")

val ldConfig: LDConfig = LDConfig.Builder()
    .setMobileKey("MOBILE_KEY")
    .setSecondaryMobileKeys(otherKeys)
    .build()

val user: LDUser = LDUser.Builder("user key")
    .email("fake@example.com")
    .build()

LDClient.init(application, ldConfig, user)
```

</CodeTabItem>
</CodeTabs>

 To access the secondary mobile key instances, use the `getForMobileKey` method on LDClient. This method takes the identifier name assigned to your environment key in the `secondaryMobileKeys` map and returns the associated LDClient instance.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDClient coreInstance = LDClient.getForMobileKey("core");
coreInstance.boolVariation("core-flag", false);
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val coreInstance: LDClient = LDClient.getForMobileKey("core")
coreInstance.boolVariation("core-flag", false)
```

</CodeTabItem>
</CodeTabs>

As all the client instances use the same LDUser object, some calls will affect all instances.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDClient coreInstance = LDClient.getForMobileKey("core");

// Calls affect all LDClient Instances
coreInstance.identify(/*User Object*/);
coreInstance.flush();
coreInstance.setOffline();
coreInstance.setOnline();
coreInstance.close();
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val coreInstance: LDClient = LDClient.getForMobileKey("core")

// Calls affect all LDClient Instances
coreInstance.identify(/*User Object*/)
coreInstance.flush()
coreInstance.setOffline()
coreInstance.setOnline()
coreInstance.close()
```

</CodeTabItem>
</CodeTabs>

Track calls, listeners, and flag evaluation are all tied to the client instance they are evaluated against.

## Monitoring SDK Status

<Callout intent="info">
  <CalloutTitle>Availablility</CalloutTitle>
<CalloutDescription>
This has been available since version 2.8.0</CalloutDescription>
</Callout>

The Android SDK exposes some of its internal status through new APIs to allow your application to monitor the SDK's status. This is provided primarily as a mechanism for the application to determine how recently the internal flag cache has been updated with the most recent values, as well as diagnosing potential reasons for the flag cache to be out of date.

The SDK has seven connectivity states dependent on its configuration, application foreground state, network connectivity, as well as calls explicitly setting the client offline or online. A summary of these states is given below.

<Table>
  <TableHeader>
    <TableHeadCell>Connection Mode</TableHeadCell>
    <TableHeadCell>Description</TableHeadCell>
  </TableHeader>
  <TableBody>
    <TableRow>
      <TableCell>
        <code>STREAMING</code>
      </TableCell>
      <TableCell>
        The SDK is either connected to the flag stream, or is actively attempting to acquire a connection.
      </TableCell>
    </TableRow>
    <TableRow>
      <TableCell>
        <code>POLLING</code>
      </TableCell>
      <TableCell>The SDK was configured with streaming disabled, and is in foreground polling mode.</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>
        <code>BACKGROUND_POLLING</code>
      </TableCell>
      <TableCell>
        The SDK has detected the application is in the background and has transitioned to battery conscious background
        polling.
      </TableCell>
    </TableRow>
    <TableRow>
      <TableCell>
        <code>BACKGROUND_DISABLED</code>
      </TableCell>
      <TableCell>
        The SDK was configured with background polling disabled. The SDK has detected the application is in the
        background and is not attempting to update the flag cache.
      </TableCell>
    </TableRow>
    <TableRow>
      <TableCell>
        <code>OFFLINE</code>
      </TableCell>
      <TableCell>
        The SDK has detected that the mobile device does not have an active network connection so has ceased flag update
        attempts until the network status changes.
      </TableCell>
    </TableRow>
    <TableRow>
      <TableCell>
        <code>SET_OFFLINE</code>
      </TableCell>
      <TableCell>
        The SDK has been explicitly set offline, either in the initial configuration, by <code>setOffline()</code>, or
        as a result of failed authentication to LaunchDarkly. The SDK will stay offline unless <code>setOnline()</code>{' '}
        is called.
      </TableCell>
    </TableRow>
    <TableRow>
      <TableCell>
        <code>SHUTDOWN</code>
      </TableCell>
      <TableCell>
        The shutdown state indicates the SDK has been permanently shutdown as a result of a call to <code>close()</code>
        .
      </TableCell>
    </TableRow>
  </TableBody>
</Table>

The SDK also internally stores a timestamp of the most recent successful and failed connections to LaunchDarkly, as well as information related to the most recent failed connection. The `LDClient` method `getConnectionInformation()` returns a structure allowing retrieval of these fields.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDClient ldClient = LDClient.get();
ConnectionInformation connectionInfo = ldClient.getConnectionInformation();
// One of the seven modes described above
ConnectionInformation.ConnectionMode connectionMode =
  connectionInfo.getConnectionMode();
// Most recent successful flag cache update in millis from the epoch
// Or null if flags have never been retrieved
Long lastSuccess = connectionInfo.getLastSuccessfulConnection();
// Most recent unsuccessful flag cache update attempt in millis from the epoch
// Or null if flag update has never been attempted
Long lastSuccess = connectionInfo.getLastFailedConnection();
// Most recent failure or null
LDFailure ldFailure = connectionInfo.getLastFailure();
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val ldClient: LDClient = LDClient.get()
val connectionInfo: ConnectionInformation = ldClient.connectionInformation
// One of the seven modes described above
val connectionMode: ConnectionInformation.ConnectionMode =
    connectionInfo.connectionMode
// Most recent successful flag cache update in millis from the epoch
// Or null if flags have never been retrieved
val lastSuccess: Long? = connectionInfo.lastSuccessfulConnection
// Most recent unsuccessful flag cache update attempt in millis from the epoch
// Or null if flag update has never been attempted
val lastSuccess: Long? = connectionInfo.lastFailedConnection
// Most recent failure or null
val ldFailure: LDFailure? = connectionInfo.lastFailure
```

</CodeTabItem>
</CodeTabs>

`LDFailure` is a `LaunchDarklyException` with an associated `FailureType`. It may include a `.cause()` propagated from an underlying exception associated with the update's failure. The cause itself should be considered unstable as it is dependent on internal implementation, though the mechanism to retrieve it will be maintained. The failure types are summarized below.

<Table>
  <TableHeader>
    <TableHeadCell>FailureType</TableHeadCell>
    <TableHeadCell>Description</TableHeadCell>
  </TableHeader>
  <TableBody>
    <TableRow>
      <TableCell>
        <code>INVALID_RESPONSE_BODY</code>
      </TableCell>
      <TableCell>A response body received either through polling or streaming was unable to be parsed.</TableCell>
    </TableRow>
    <TableRow>
      <TableCell>
        <code>NETWORK_FAILURE</code>
      </TableCell>
      <TableCell>
        A network request for polling, or the <code>EventSource</code> stream reported a failure.
      </TableCell>
    </TableRow>
    <TableRow>
      <TableCell>
        <code>UNEXPECTED_STREAM_ELEMENT_TYPE</code>
      </TableCell>
      <TableCell>
        An event was received through the stream was had an unknown event name. This could indicate a newer SDK is
        available if new event types have become available through the flag stream since the SDKs release.
      </TableCell>
    </TableRow>
    <TableRow>
      <TableCell>
        <code>UNEXPECTED_RESPONSE_CODE</code>
      </TableCell>
      <TableCell>
        This indicates the <code>LDFailure</code> is an instance of <code>LDInvalidResponseCodeFailure</code>. See below
        for more details.
      </TableCell>
    </TableRow>
    <TableRow>
      <TableCell>
        <code>UNKNOWN_ERROR</code>
      </TableCell>
      <TableCell>Some other issue occurred.</TableCell>
    </TableRow>
  </TableBody>
</Table>

If matching on the `FailureType`, a default case should be used to handle any future cases provided. The `UNEXPECTED_RESPONSE_CODE` case indicates that the `LDFailure` is can be cast to a `LDInvalidResponseCodeFailure` for more information. This more specific failure includes a response code and whether the failure is considered retryable. An example is given below.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
LDClient ldClient = LDClient.get();
ConnectionInformation connectionInfo = ldClient.getConnectionInformation();
LDFailure ldFailure = connectionInfo.getLastFailure();
if (ldFailure != null) {
    Timber.d("Received failure with message %s", ldFailure.getMessage());
    // Retrieve the failure type
    LDFailure.FailureType failureType = ldFailure.getFailureType();
    switch (failureType) {
        case INVALID_RESPONSE_BODY:
            Timber.d("Received invalid response body");
            break;
        case NETWORK_FAILURE:
            Timber.d("Network failure, may have bad connection");
            break;
        case UNEXPECTED_STREAM_ELEMENT_TYPE:
            Timber.d("Unexpected stream element, may require update");
            break;
        case UNEXPECTED_RESPONSE_CODE:
            LDInvalidResponseCodeFailure responseCodeFailure =
                (LDInvalidResponseCodeFailure) ldFailure;
            int responseCode = responseCodeFailure.getResponseCode();
            if (responseCodeFailure.isRetryable()) {
                Timber.d("Received invalid response code %d", responseCode);
            } else {
                Timber.d("Received invalid response code %d, giving up", responseCode);
            }
            break;
        case UNKNOWN_ERROR:
        default:
            Timber.d("Unknown error");
            break;
    }

    Throwable cause = ldFailure.getCause();
    if (cause != null) {
        // Do something with underlying cause
    }
}
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
val ldClient: LDClient = LDClient.get()
val connectionInfo: ConnectionInformation = ldClient.connectionInformation
val ldFailure: LDFailure? = connectionInfo.lastFailure
if (ldFailure != null) {
    Timber.d("Received failure with message %s", ldFailure.message)
    // Retrieve the failure type
    val failureType: LDFailure.FailureType = ldFailure.failureType
    when (failureType) {
        INVALID_RESPONSE_BODY -> {
            Timber.d("Received invalid response body")
        }
        NETWORK_FAILURE -> {
            Timber.d("Network failure, may have bad connection")
        }
        UNEXPECTED_STREAM_ELEMENT_TYPE -> {
            Timber.d("Unexpected stream element, may require update")
        }
        UNEXPECTED_RESPONSE_CODE -> {
            val responseCodeFailure: LDInvalidResponseCodeFailure =
                ldFailure as LDInvalidResponseCodeFailure
            val responseCode = responseCodeFailure.responseCode
            if (responseCodeFailure.isRetryable) {
                Timber.d("Received invalid response code %d", responseCode)
            } else {
                Timber.d("Received invalid response code %d, giving up", responseCode)
            }
        }
        UNKNOWN_ERROR -> {
            Timber.d("Unknown error")
        }
    }
    val cause: Throwable? = ldFailure.cause
    if (cause != null) {
        // Do something with underlying cause
    }
}
```

</CodeTabItem>
</CodeTabs>

A callback based interface is also provided to allow notifying the application when the `ConnectionMode` changes as well as whenever the `LDFailure` in `ConnectionStatus` changes. The application must provide a class instance implementing `LDStatusListener` to the SDK client instance method `registerStatusListener` to register the listeners with the SDK. A brief example is given below.

<Callout intent="alert">
  <CalloutTitle>Listener Weak Reference</CalloutTitle>
<CalloutDescription>

The SDK maintains only a weak reference to the registered `LDStatusListener`, so a reference should be maintained by the application for as long as the application desires the listener to be available. This was designed to help prevent creating an inadvertent long term reference to an Activity by creating a static internal class instance for use as a listener. By using a weak reference to the listener, the Activity can still be garbage collected normally, even if it maintains a registered `LDStatusListener` (though unregistering the listener when finished is still recommended).

</CalloutDescription>
</Callout>


<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
class MainActivity extends Activity {
    private LDClient ldClient;
    private LDStatusListener ldStatusListener;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        ldStatusListener = new LDStatusListener() {
            @Override
            public void onConnectionModeChanged(ConnectionInformation connectionInfo) {
                // handle new connection info
            }

            @Override
            public void onInternalFailure(LDFailure ldFailure) {
                // handle failure
            }
        };

        ldClient = LDClient.get();
        ldClient.registerStatusListener(ldStatusListener);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        ldClient.unregisterStatusListener(ldStatusListener);
    }
}
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
class MainActivity : Activity() {
    private var ldClient: LDClient? = null
    private var ldStatusListener: LDStatusListener? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        ldStatusListener = object : LDStatusListener {
            override fun onConnectionModeChanged(connectionInfo: ConnectionInformation) {
                // handle new connection info
            }

            override fun onInternalFailure(ldFailure: LDFailure) {
                // handle failure
            }
        }

        ldClient = LDClient.get()
        ldClient.registerStatusListener(ldStatusListener)
    }

    override fun onDestroy() {
        super.onDestroy()
        ldClient?.unregisterStatusListener(ldStatusListener)
    }
}
```

</CodeTabItem>
</CodeTabs>

## Troubleshooting

The Android SDK makes heavy use of the Timber logging. Include Timber in your application to enable debug output or production logging. An example is shown below to enable debug output when the application is built with a debug configuration.

<CodeTabs
  defaultValue="java"
  values={[
    { label: 'Java', value: 'java', },
    { label: 'Kotlin', value: 'kotlin' }
  ]
}>
<CodeTabItem value="java">

```java
if (BuildConfig.DEBUG) {
    Timber.plant(new Timber.DebugTree());
}
```

</CodeTabItem>
<CodeTabItem value="kotlin">

```kotlin
if (BuildConfig.DEBUG) {
    Timber.plant(Timber.DebugTree())
}
```

</CodeTabItem>
</CodeTabs>
